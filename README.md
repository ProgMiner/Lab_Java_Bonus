# server-architecture-tester

Приложение для тестирования производительности различных серверных архитектур на языке Java.

Поддерживаются три вида архитектур:

- `BLOCK` — обычная блокирующая архитектура с двумя потоками на клиента: для считывания
  и для записи

- `NONBLOCK` — неблокирующая архитектура с `Selector`, используется два потока на все соединения

- `ASYNC` — блокирующая асинхронная архитектура с использованием асинхронных каналов из Java NIO

Все архитектуры используют для вычисления задачи пул потоков одинакового фиксированного размера.

## Сборка

Для сборки требуется:

- Java 8
- Maven
- Компилятор Protobuf (`protoc`)

Команда сборки:

```bash
mvn package
```

Запускаемым артефактом сборки является файл
`./target/servertester-1.0-SNAPSHOT-jar-with-dependencies.jar`.

## Запуск

Для запуска используется команда:

```bash
java -jar ./target/servertester-1.0-SNAPSHOT-jar-with-dependencies.jar [args...]
```

Программа настраивается с помощью опционального файла `./config.properties` и опциональных
аргументов командной строки. Аргументы командной строки задаются в формате `--key=value` и
переопределяют значения, указанные в файле конфигурации.

Доступные параметры конфигурации:

- `arch` — архитектура сервера для тестирования (из списка выше, регистр не важен)

- `client_requests` — число запросов, посылаемых одним клиентом

- `array_size` — размер массива (переменная)

- `clients` — число клиентов (переменная)

- `request_delta` — ожидание клиента между получением ответа на запрос и отправкой следующего
  запроса в миллисекундах (переменная)

- `output_dir` — путь до директории, в которую будут записаны результаты теста

Те параметры, которые помечены как переменная, могут быть заданы в формате `begin..end, step`
(пробелы не важны). Всего должен быть ровно один переменный параметр.

Все параметры обязательные.

В результате работы создаётся директория, указанная в параметре `output_dir`, и файлы в ней:

- `config.txt` — конфигурация теста

- `data.csv` — CSV файл с результатами тестирования

Результаты тестирования представлены в виде таблицы со следующими столбцами:

- Переменный параметр (имя столбца зависит от выбранного переменного параметра)

- `computation time` — время выполнения вычислительной задачи на сервере (мс)

- `server request time` — время выполнения запроса на сервере от момента начала получения запроса
  до момента отправки ответа (мс)

- `client request time` — время ожидания обработки одного запроса на клиенте (мс)

Все метрики усредняются по клиентам и запросам.

## Скрипты запуска и построения графиков

В репозитории подготовлен файл скрипта запуска тестов по всем параметрам и соответствующий ему
файл конфигурации. Для запуска используется команда:

```bash
./run.sh
```

Детали внутри файла скрипта.

Также в репозитории подготовлен скрипт для построения графиков, согласованный со скриптом запуска.
Он вызывается командой:

```bash
./plot.py
```

Скрипт использует Python 3 и следующие зависимости:

- numpy

- pandas

- matplotlib


# Результаты тестирования

Тестирование проводилось для следующих значений параметров:

```
client_requests=50
array_size=5000
clients=50
request_delta=50
```

При этом, каждый из переменных параметров варьировался в отдельности по следующим правилам:

```
array_size:1000..10000,1000
clients:10..100,10
request_delta:0..100,10
```

Были получены следующие графики (при нажатии открываются в большом размере):

| Переменный параметр | Computation time | Server request time | Client request time |
|:--------------------|:----------------:|:-------------------:|:-------------------:|
| Array size | <img src="./plots/array_size/computation time.png"> | <img src="./plots/array_size/server request time.png"> | <img src="./plots/array_size/client request time.png"> |
| Clients | <img src="./plots/clients/computation time.png"> | <img src="./plots/clients/server request time.png"> | <img src="./plots/clients/client request time.png"> |
| Request delta | <img src="./plots/request_delta/computation time.png"> | <img src="./plots/request_delta/server request time.png"> | <img src="./plots/request_delta/client request time.png"> |

## Наблюдения и выводы

- Асинхронный сервер никогда не работает быстрее блокирующего и неблокирующего из-за накладных
  расходов на переключение контекста.

- При маленьком размере задачи (как по времени, так и по объёму сообщения) все архитектуры ведут
  себя одинаково (до 4000 на графиках). После этого наступает момент равновесия (5000), когда
  клиенты естественным образом выстраиваются в очередь и за счёт ожидания выполнения вычислений
  не происходит "толкучки" при отправке данных, поэтому клиенты в итоге обрабатываются быстрее.
  Далее у всех архитектур начинается резкий рост времени обработки пакета, непропорциональный
  росту времени вычислений. Это происходит из-за ожидания задач в очереди тредпула.

- При увеличении числа клиентов время вычисления растёт незначительно и связано с переключениями
  контекста исполнения.

- При этом на среднего размера задаче увеличение числа клиентов приводит к росту времени обработки
  пакета на сервере. Сначала все архитектуры справляются примерно одинаково, а после 80 клиентов
  время начинает стремительно расти. Для блокирующей архитектуры это связано с частыми
  переключениями контекста, для двух других — с возникающей очередью клиентов в потоках
  ввода-вывода.

- Время ожидания клиента при увеличении числа клиентов почти не отличается от времени обработки
  пакета (с точностью до константы) кроме блокирующего сервера. За счёт использования отдельных
  потоков, конкретному клиенту ответ приходит быстрее, чем когда один поток занимается всеми
  клиентами. Но это проявляется только на небольшом числе клиентов. После превышения 80 клиентов
  ситуация становится одинаковой для всех архитектур.

- Увеличение времени задержки между запросами очевидно приводит к уменьшению как времени вычисления,
  так и времени обработки и ожидания.

- Интересно заметить, что между графиками обработки пакета и ожидания клиента для блокирующего и
  неблокирующего серверов наблюдается заметная разница, а асинхронный сервер обрабатывает пакеты
  почти столько же времени, сколько клиент ожидает ответа. То есть время передачи данных почти
  нулевое. Такой же эффект наблюдается для всех пар соответствующих графиков и может быть вызван
  тем, что асинхронный сервер внутри использует блокирующее чтение и запись, а значит тратит меньше
  вызовов для передачи конкретного пакета. Но, в отличие от простого блокирующего сервера, он
  использует всего один поток, из-за чего ввод-вывод происходит в каждый момент времени лишь для
  одного клиента, что также позволяет быстрее передавать данные.
